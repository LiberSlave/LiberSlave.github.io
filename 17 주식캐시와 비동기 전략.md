``` python 
# database.py
class StockCache:
    def __init__(self):
        self._name_to_ticker = {}  # 빠른 조회용
        self._ticker_to_info = {}  # 상세 정보용
        self._df = None           # 복합 쿼리용
        self._last_updated = None
        
    def refresh_cache(self, engine):
        """DB에서 최신 데이터로 캐시 갱신"""
        query = "SELECT ticker, name, market_cap FROM stock"
        self._df = pd.read_sql(query, engine)
        
        # 빠른 조회용 딕셔너리 구성
        self._name_to_ticker = dict(zip(self._df['name'], self._df['ticker']))
        self._ticker_to_info = self._df.set_index('ticker').to_dict('index')
        self._last_updated = datetime.now()
        
    def get_ticker(self, name: str) -> str:
        """O(1) 조회"""
        return self._name_to_ticker.get(name)
        
    def get_stock_info(self, ticker: str) -> dict:
        """티커로 상세 정보 조회"""
        return self._ticker_to_info.get(ticker)
        
    def search_stocks(self, **kwargs) -> pd.DataFrame:
        """복합 조건 검색 (시가총액 범위 등)"""
        df = self._df.copy()
        for key, value in kwargs.items():
            if key in df.columns:
                df = df[df[key] == value]
        return df
        
    def get_valid_tickers(self) -> set:
        """유효한 티커 목록 (foreign key 체크용)"""
        return set(self._df['ticker'])

# 전역 캐시 인스턴스
stock_cache = StockCache()
```

``` python
# main.py
from database import stock_cache, get_engine

@app.on_event("startup")
async def startup_event():
    """서버 시작 시 캐시 초기화"""
    engine = get_engine()
    stock_cache.refresh_cache(engine)
    logger.info(f"Stock cache initialized with {len(stock_cache._name_to_ticker)} stocks")

# 기존 TICKER_MAPPING 대신 사용
def get_ticker_mapping():
    return stock_cache._name_to_ticker
```

``` python
# database.py 수정
async def batch_save_news(engine, news_items: List[Dict]):
    # ...existing code...
    
    # 기존: DB 조회
    # with engine.connect() as conn:
    #     valid_tickers = set(row[0] for row in conn.execute(text("SELECT ticker FROM stock")))
    
    # 새로운: 캐시 활용 (DB 조회 없음!)
    valid_tickers = stock_cache.get_valid_tickers()
    
    mapping_rows = [row for row in mapping_rows if row['ticker'] in valid_tickers]
    # ...existing code...
```

``` python
# 주기적 갱신 (예: 하루 1회)
@app.post("/admin/refresh-stock-cache")
async def refresh_stock_cache():
    """관리자용: 수동 캐시 갱신"""
    engine = get_engine()
    stock_cache.refresh_cache(engine)
    return {"message": "Stock cache refreshed successfully"}

# 또는 자동 갱신 체크
def ensure_cache_fresh():
    """캐시가 오래되면 자동 갱신"""
    if (datetime.now() - stock_cache._last_updated).days >= 1:
        engine = get_engine()
        stock_cache.refresh_cache(engine)
```

## 결론

**DB 테이블 + 딕셔너리 캐싱** 조합이 최적입니다:

1. **성능**: O(1) 조회 유지
2. **확장성**: DB 테이블로 유연한 데이터 관리
3. **효율성**: 불필요한 DB 조회 제거 (하루 200번 → 1번)
4. **호환성**: 기존 코드 수정 최소화

DataFrame은 복합 검색이 필요할 때만 사용하고, 일반적인 name↔ticker 변환은 딕셔너리를 사용하는 것이 훨씬 효율적입니다.


### 비동기 함수 고찰

process_and_save_minute 이 함수 안에 하나라도 동기함수가 쓰이면 process_and_save_minute 는 동기함수처럼 동작하지? 관련된 모든함수를 비동기로 만들게 아니라면 걍 다 동기로 만들고 asyncio.to_thread(process_and_save_minute,fla ...) 이런식으로 구현해서 비동기를 구현하느게 훨씬 나은 방법인가?

답변:
 **모든 함수를 비동기로 바꾸기는 현실적으로 어려움**

- `requests` → `httpx` (비동기)
- `pymysql` → `aiomysql` (비동기)
- `sqlite3` → `aiosqlite` (비동기)
- 모든 라이브러리를 교체해야 하고, 코드도 대폭 수정해야 함
**현실적으로 [asyncio.to_thread()](vscode-file://vscode-app/c:/Users/%EC%86%90%EB%AF%BC%EA%B5%AC/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 방식이 훨씬 나은 선택입니다:**

- 기존 코드 유지 + FastAPI 비동기 성능 확보
- 개발 비용 최소화 + 실용적 해결책
- 실제 서비스에서도 많이 사용하는 패턴

**완전한 비동기 구현은 새 프로젝트에서 처음부터 설계할 때 고려하는 것이 좋습니다.**








stock_cache.df의 생김새
![[Pasted image 20250706120904.png]]



processed_info 데이터 생긴거
{

        "name": name,               # 종목명

        "market_cap": market_cap,   # 시가총액: 정수

        "rate": rate,               # 등락률: 실수

        "high": high,               # 당일 고가: 정수, 절댓값

        "current": current,         # 당일 현재가: 정수, 절댓값

        "pred_pre": pred_pre,       # 전일대비: 정수

        "close_pre": close_pre,     # 전일 종가

        "high_rate": high_rate,     # 고가 등락률

        "upl_pric": upl_pric,       # 상한가: 정수, 절댓값
        
        "margin_rate": margin_rate,  # 증거금율: 
        
        "deposit": deposit,         # 내 예수금
        
}
   
